
AutoSys2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000452  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003de  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  00800100  00800100  00000452  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000452  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000484  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000050  00000000  00000000  000004c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000019e  00000000  00000000  00000514  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000000f8  00000000  00000000  000006b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000002c2  00000000  00000000  000007aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000154  00000000  00000000  00000a6c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001b6  00000000  00000000  00000bc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002bb  00000000  00000000  00000d76  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000040  00000000  00000000  00001031  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	57 c0       	rjmp	.+174    	; 0xb4 <__bad_interrupt>
   6:	00 00       	nop
   8:	55 c0       	rjmp	.+170    	; 0xb4 <__bad_interrupt>
   a:	00 00       	nop
   c:	53 c0       	rjmp	.+166    	; 0xb4 <__bad_interrupt>
   e:	00 00       	nop
  10:	51 c0       	rjmp	.+162    	; 0xb4 <__bad_interrupt>
  12:	00 00       	nop
  14:	4f c0       	rjmp	.+158    	; 0xb4 <__bad_interrupt>
  16:	00 00       	nop
  18:	4d c0       	rjmp	.+154    	; 0xb4 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	39 c1       	rjmp	.+626    	; 0x290 <__vector_7>
  1e:	00 00       	nop
  20:	49 c0       	rjmp	.+146    	; 0xb4 <__bad_interrupt>
  22:	00 00       	nop
  24:	5e c1       	rjmp	.+700    	; 0x2e2 <__vector_9>
  26:	00 00       	nop
  28:	45 c0       	rjmp	.+138    	; 0xb4 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	43 c0       	rjmp	.+134    	; 0xb4 <__bad_interrupt>
  2e:	00 00       	nop
  30:	41 c0       	rjmp	.+130    	; 0xb4 <__bad_interrupt>
  32:	00 00       	nop
  34:	3f c0       	rjmp	.+126    	; 0xb4 <__bad_interrupt>
  36:	00 00       	nop
  38:	3d c0       	rjmp	.+122    	; 0xb4 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	3b c0       	rjmp	.+118    	; 0xb4 <__bad_interrupt>
  3e:	00 00       	nop
  40:	39 c0       	rjmp	.+114    	; 0xb4 <__bad_interrupt>
  42:	00 00       	nop
  44:	37 c0       	rjmp	.+110    	; 0xb4 <__bad_interrupt>
  46:	00 00       	nop
  48:	35 c0       	rjmp	.+106    	; 0xb4 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	33 c0       	rjmp	.+102    	; 0xb4 <__bad_interrupt>
  4e:	00 00       	nop
  50:	31 c0       	rjmp	.+98     	; 0xb4 <__bad_interrupt>
  52:	00 00       	nop
  54:	2f c0       	rjmp	.+94     	; 0xb4 <__bad_interrupt>
  56:	00 00       	nop
  58:	2d c0       	rjmp	.+90     	; 0xb4 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	2b c0       	rjmp	.+86     	; 0xb4 <__bad_interrupt>
  5e:	00 00       	nop
  60:	29 c0       	rjmp	.+82     	; 0xb4 <__bad_interrupt>
  62:	00 00       	nop
  64:	27 c0       	rjmp	.+78     	; 0xb4 <__bad_interrupt>
  66:	00 00       	nop
  68:	25 c0       	rjmp	.+74     	; 0xb4 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	23 c0       	rjmp	.+70     	; 0xb4 <__bad_interrupt>
  6e:	00 00       	nop
  70:	21 c0       	rjmp	.+66     	; 0xb4 <__bad_interrupt>
  72:	00 00       	nop
  74:	1f c0       	rjmp	.+62     	; 0xb4 <__bad_interrupt>
  76:	00 00       	nop
  78:	1d c0       	rjmp	.+58     	; 0xb4 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	1b c0       	rjmp	.+54     	; 0xb4 <__bad_interrupt>
  7e:	00 00       	nop
  80:	19 c0       	rjmp	.+50     	; 0xb4 <__bad_interrupt>
  82:	00 00       	nop
  84:	17 c0       	rjmp	.+46     	; 0xb4 <__bad_interrupt>
  86:	00 00       	nop
  88:	15 c0       	rjmp	.+42     	; 0xb4 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	13 c0       	rjmp	.+38     	; 0xb4 <__bad_interrupt>
  8e:	00 00       	nop
  90:	11 c0       	rjmp	.+34     	; 0xb4 <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_clear_bss>:
  a0:	21 e0       	ldi	r18, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
  a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
  aa:	a5 30       	cpi	r26, 0x05	; 5
  ac:	b2 07       	cpc	r27, r18
  ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>
  b0:	d5 d0       	rcall	.+426    	; 0x25c <main>
  b2:	93 c1       	rjmp	.+806    	; 0x3da <_exit>

000000b4 <__bad_interrupt>:
  b4:	a5 cf       	rjmp	.-182    	; 0x0 <__vectors>

000000b6 <initGPIO>:
volatile unsigned char bToggle = 0;	// This registers is a boolean that is set when an interrupt 6 occurs and cleared when serviced in the code.
//These registers is available outside of the main loop (i.e., to the interrupt handlers)
volatile unsigned char LEDpattern, LEDperiod, LEDcountD;	// 3 bytes related to the 5 LEDs

int initGPIO(void)
{
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	cd b7       	in	r28, 0x3d	; 61
  bc:	de b7       	in	r29, 0x3e	; 62
	//Set up input output direction on Port C and G
	DDRB |= (1<<DB_LED);	// Set the display backlight's IO pin an an output. Leave other bits as they were.
  be:	84 e2       	ldi	r24, 0x24	; 36
  c0:	90 e0       	ldi	r25, 0x00	; 0
  c2:	24 e2       	ldi	r18, 0x24	; 36
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	f9 01       	movw	r30, r18
  c8:	20 81       	ld	r18, Z
  ca:	20 68       	ori	r18, 0x80	; 128
  cc:	fc 01       	movw	r30, r24
  ce:	20 83       	st	Z, r18
	DDRC = 0b00000111;		// Set the direction of the IO pins on Port C to output on the 3 least significant bits and input on the 5 higher ones. 5 buttons and 3 LEDs.
  d0:	87 e2       	ldi	r24, 0x27	; 39
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	27 e0       	ldi	r18, 0x07	; 7
  d6:	fc 01       	movw	r30, r24
  d8:	20 83       	st	Z, r18
	DDRG |= 0b00000011;		// set the direction of the IO pins on Port G's lower 2 bytes as output (LEDs 1 & 2). Leave the other bits as they were.
  da:	83 e3       	ldi	r24, 0x33	; 51
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	23 e3       	ldi	r18, 0x33	; 51
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	f9 01       	movw	r30, r18
  e4:	20 81       	ld	r18, Z
  e6:	23 60       	ori	r18, 0x03	; 3
  e8:	fc 01       	movw	r30, r24
  ea:	20 83       	st	Z, r18
	return(0);
  ec:	80 e0       	ldi	r24, 0x00	; 0
  ee:	90 e0       	ldi	r25, 0x00	; 0
}
  f0:	df 91       	pop	r29
  f2:	cf 91       	pop	r28
  f4:	08 95       	ret

000000f6 <initExtInt>:

int initExtInt(void)
{
  f6:	cf 93       	push	r28
  f8:	df 93       	push	r29
  fa:	cd b7       	in	r28, 0x3d	; 61
  fc:	de b7       	in	r29, 0x3e	; 62
	//Set up external Interrupts
	// The five Switches are ORed to Pin PE6 which is alternatively Int6
	EICRB |= (0<<ISC61) | (1<<ISC60);  //Any logical change to INT6 generates an interrupt
  fe:	8a e6       	ldi	r24, 0x6A	; 106
 100:	90 e0       	ldi	r25, 0x00	; 0
 102:	2a e6       	ldi	r18, 0x6A	; 106
 104:	30 e0       	ldi	r19, 0x00	; 0
 106:	f9 01       	movw	r30, r18
 108:	20 81       	ld	r18, Z
 10a:	20 61       	ori	r18, 0x10	; 16
 10c:	fc 01       	movw	r30, r24
 10e:	20 83       	st	Z, r18
	EIMSK |= (1<<INTF6);
 110:	8d e3       	ldi	r24, 0x3D	; 61
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	2d e3       	ldi	r18, 0x3D	; 61
 116:	30 e0       	ldi	r19, 0x00	; 0
 118:	f9 01       	movw	r30, r18
 11a:	20 81       	ld	r18, Z
 11c:	20 64       	ori	r18, 0x40	; 64
 11e:	fc 01       	movw	r30, r24
 120:	20 83       	st	Z, r18
	return(6);
 122:	86 e0       	ldi	r24, 0x06	; 6
 124:	90 e0       	ldi	r25, 0x00	; 0
}
 126:	df 91       	pop	r29
 128:	cf 91       	pop	r28
 12a:	08 95       	ret

0000012c <initTimer2>:


int initTimer2()
{
 12c:	cf 93       	push	r28
 12e:	df 93       	push	r29
 130:	cd b7       	in	r28, 0x3d	; 61
 132:	de b7       	in	r29, 0x3e	; 62
	/// Set up an internal Interrupt that will occur every 5 milliseconds.
	/// It uses the Timer Counter 2 in CTC mode with a pre-scaler of 256 and a value of 155 (it should be 155.25).
	// 
	TCCR2A = (1<<WGM21); // | (0<<WGM20);  //CTC mode
 134:	80 eb       	ldi	r24, 0xB0	; 176
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	28 e0       	ldi	r18, 0x08	; 8
 13a:	fc 01       	movw	r30, r24
 13c:	20 83       	st	Z, r18
	//TCCR2A |= (0<<COM2A1) | (0<<COM2A0); // Mormal port operation, OC2A is disconnected.
	TCCR2A |= (1<<CS22) | (1<<CS21); //| (0<<CS20); /// Divide source frequency source by 256.
 13e:	80 eb       	ldi	r24, 0xB0	; 176
 140:	90 e0       	ldi	r25, 0x00	; 0
 142:	20 eb       	ldi	r18, 0xB0	; 176
 144:	30 e0       	ldi	r19, 0x00	; 0
 146:	f9 01       	movw	r30, r18
 148:	20 81       	ld	r18, Z
 14a:	26 60       	ori	r18, 0x06	; 6
 14c:	fc 01       	movw	r30, r24
 14e:	20 83       	st	Z, r18
	TCNT2 = 0;	/// Make sure the timer counter is set to 0.
 150:	82 eb       	ldi	r24, 0xB2	; 178
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	fc 01       	movw	r30, r24
 156:	10 82       	st	Z, r1
	OCR2A = 155;
 158:	83 eb       	ldi	r24, 0xB3	; 179
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	2b e9       	ldi	r18, 0x9B	; 155
 15e:	fc 01       	movw	r30, r24
 160:	20 83       	st	Z, r18
	TIMSK2 = (1<<OCF2A); // Interrupt flag register to enable output compare.
 162:	80 e7       	ldi	r24, 0x70	; 112
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	22 e0       	ldi	r18, 0x02	; 2
 168:	fc 01       	movw	r30, r24
 16a:	20 83       	st	Z, r18
	return(2);
 16c:	82 e0       	ldi	r24, 0x02	; 2
 16e:	90 e0       	ldi	r25, 0x00	; 0
}
 170:	df 91       	pop	r29
 172:	cf 91       	pop	r28
 174:	08 95       	ret

00000176 <flashLEDs>:

int  flashLEDs()
{
 176:	cf 93       	push	r28
 178:	df 93       	push	r29
 17a:	1f 92       	push	r1
 17c:	cd b7       	in	r28, 0x3d	; 61
 17e:	de b7       	in	r29, 0x3e	; 62
	unsigned char temp;			//Allocate a temporary byte. Note! it is not the same byte as the byte named temp in the main routine. Do not confuse them even if they have the same name.
	if (LEDcountD != 0)
 180:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <LEDcountD>
 184:	88 23       	and	r24, r24
 186:	31 f0       	breq	.+12     	; 0x194 <flashLEDs+0x1e>
	{
		LEDcountD--;		// Decrement the countdown timer for another 5ms until it reaches 0
 188:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <LEDcountD>
 18c:	81 50       	subi	r24, 0x01	; 1
 18e:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDcountD>
 192:	60 c0       	rjmp	.+192    	; 0x254 <flashLEDs+0xde>
	} 
	else
	{
		LEDcountD = LEDperiod;	// Reset the countdown timer
 194:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <LEDperiod>
 198:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDcountD>
		temp = LEDpattern & 0b00011111;
 19c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <LEDpattern>
 1a0:	8f 71       	andi	r24, 0x1F	; 31
 1a2:	89 83       	std	Y+1, r24	; 0x01
		switch (LEDpattern & 0b11100000)
 1a4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <LEDpattern>
 1a8:	88 2f       	mov	r24, r24
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	80 7e       	andi	r24, 0xE0	; 224
 1ae:	99 27       	eor	r25, r25
 1b0:	80 34       	cpi	r24, 0x40	; 64
 1b2:	91 05       	cpc	r25, r1
 1b4:	c1 f0       	breq	.+48     	; 0x1e6 <flashLEDs+0x70>
 1b6:	80 38       	cpi	r24, 0x80	; 128
 1b8:	91 05       	cpc	r25, r1
 1ba:	19 f0       	breq	.+6      	; 0x1c2 <flashLEDs+0x4c>
 1bc:	80 97       	sbiw	r24, 0x20	; 32
 1be:	d1 f0       	breq	.+52     	; 0x1f4 <flashLEDs+0x7e>
 1c0:	27 c0       	rjmp	.+78     	; 0x210 <flashLEDs+0x9a>
		{
			case 0b10000000:
				temp = temp<<1;
 1c2:	89 81       	ldd	r24, Y+1	; 0x01
 1c4:	88 0f       	add	r24, r24
 1c6:	89 83       	std	Y+1, r24	; 0x01
				if (temp & 0b00100000)
 1c8:	89 81       	ldd	r24, Y+1	; 0x01
 1ca:	88 2f       	mov	r24, r24
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	80 72       	andi	r24, 0x20	; 32
 1d0:	99 27       	eor	r25, r25
 1d2:	89 2b       	or	r24, r25
 1d4:	39 f0       	breq	.+14     	; 0x1e4 <flashLEDs+0x6e>
				{
					temp |= 0b00000001;
 1d6:	89 81       	ldd	r24, Y+1	; 0x01
 1d8:	81 60       	ori	r24, 0x01	; 1
 1da:	89 83       	std	Y+1, r24	; 0x01
					temp &= ~0b00100000;	// Do not keep a bit set where there is supposed to be a flashing command
 1dc:	89 81       	ldd	r24, Y+1	; 0x01
 1de:	8f 7d       	andi	r24, 0xDF	; 223
 1e0:	89 83       	std	Y+1, r24	; 0x01
				}
				break;
 1e2:	16 c0       	rjmp	.+44     	; 0x210 <flashLEDs+0x9a>
 1e4:	15 c0       	rjmp	.+42     	; 0x210 <flashLEDs+0x9a>
			case 0b01000000:
				temp = ~temp;		// Invert the light pattern
 1e6:	89 81       	ldd	r24, Y+1	; 0x01
 1e8:	80 95       	com	r24
 1ea:	89 83       	std	Y+1, r24	; 0x01
				temp &= 0b00011111;	// Clear the flashing command
 1ec:	89 81       	ldd	r24, Y+1	; 0x01
 1ee:	8f 71       	andi	r24, 0x1F	; 31
 1f0:	89 83       	std	Y+1, r24	; 0x01
				break;
 1f2:	0e c0       	rjmp	.+28     	; 0x210 <flashLEDs+0x9a>
			case 0b00100000:
				if (temp & 0b00000001)
 1f4:	89 81       	ldd	r24, Y+1	; 0x01
 1f6:	88 2f       	mov	r24, r24
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	81 70       	andi	r24, 0x01	; 1
 1fc:	99 27       	eor	r25, r25
 1fe:	89 2b       	or	r24, r25
 200:	19 f0       	breq	.+6      	; 0x208 <flashLEDs+0x92>
				{
						temp |= 0b00100000;
 202:	89 81       	ldd	r24, Y+1	; 0x01
 204:	80 62       	ori	r24, 0x20	; 32
 206:	89 83       	std	Y+1, r24	; 0x01
				}
				temp = temp>>1;
 208:	89 81       	ldd	r24, Y+1	; 0x01
 20a:	86 95       	lsr	r24
 20c:	89 83       	std	Y+1, r24	; 0x01
				break;
 20e:	00 00       	nop
		}
		LEDpattern = (LEDpattern & 0b11100000)|temp;	// Update the LEDpattern with the current pattern while keeping flashing commands
 210:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <LEDpattern>
 214:	98 2f       	mov	r25, r24
 216:	90 7e       	andi	r25, 0xE0	; 224
 218:	89 81       	ldd	r24, Y+1	; 0x01
 21a:	89 2b       	or	r24, r25
 21c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <LEDpattern>
		PORTG = (PORTG & 0x11111100) | (temp & 0b00000011);	//Update the 2 Port G LEDs
 220:	84 e3       	ldi	r24, 0x34	; 52
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	fc 01       	movw	r30, r24
 226:	80 81       	ld	r24, Z
 228:	84 e3       	ldi	r24, 0x34	; 52
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	29 81       	ldd	r18, Y+1	; 0x01
 22e:	23 70       	andi	r18, 0x03	; 3
 230:	fc 01       	movw	r30, r24
 232:	20 83       	st	Z, r18
		temp = temp >>2;
 234:	89 81       	ldd	r24, Y+1	; 0x01
 236:	86 95       	lsr	r24
 238:	86 95       	lsr	r24
 23a:	89 83       	std	Y+1, r24	; 0x01
		PORTC = (PORTC & 0b11111000) | temp;	//Update the 3 Port C LEDs
 23c:	88 e2       	ldi	r24, 0x28	; 40
 23e:	90 e0       	ldi	r25, 0x00	; 0
 240:	28 e2       	ldi	r18, 0x28	; 40
 242:	30 e0       	ldi	r19, 0x00	; 0
 244:	f9 01       	movw	r30, r18
 246:	20 81       	ld	r18, Z
 248:	32 2f       	mov	r19, r18
 24a:	38 7f       	andi	r19, 0xF8	; 248
 24c:	29 81       	ldd	r18, Y+1	; 0x01
 24e:	23 2b       	or	r18, r19
 250:	fc 01       	movw	r30, r24
 252:	20 83       	st	Z, r18
	}
}
 254:	0f 90       	pop	r0
 256:	df 91       	pop	r29
 258:	cf 91       	pop	r28
 25a:	08 95       	ret

0000025c <main>:

int main(void)
{
 25c:	cf 93       	push	r28
 25e:	df 93       	push	r29
 260:	1f 92       	push	r1
 262:	cd b7       	in	r28, 0x3d	; 61
 264:	de b7       	in	r29, 0x3e	; 62
	unsigned char temp = 0x0F;		// Allocate memory for temp. It is initialized to 15 for demonstration purposes only.
 266:	8f e0       	ldi	r24, 0x0F	; 15
 268:	89 83       	std	Y+1, r24	; 0x01
	LEDpattern = 0b01000100;
 26a:	84 e4       	ldi	r24, 0x44	; 68
 26c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <LEDpattern>
	LEDperiod = 100;
 270:	84 e6       	ldi	r24, 0x64	; 100
 272:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <LEDperiod>
	LEDcountD = 0;
 276:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <LEDcountD>
	
	temp = initGPIO();				// Set up the data direction register for both ports C and G
 27a:	1d df       	rcall	.-454    	; 0xb6 <initGPIO>
 27c:	89 83       	std	Y+1, r24	; 0x01
	temp = initExtInt();			// Setup external interrupts
 27e:	3b df       	rcall	.-394    	; 0xf6 <initExtInt>
 280:	89 83       	std	Y+1, r24	; 0x01
	temp = initTimer2();			// Setup 5ms internal interrupt
 282:	54 df       	rcall	.-344    	; 0x12c <initTimer2>
 284:	89 83       	std	Y+1, r24	; 0x01
	sei();							// Set Global Interrupts
 286:	78 94       	sei
	
	while(1)
	{
	temp++;
 288:	89 81       	ldd	r24, Y+1	; 0x01
 28a:	8f 5f       	subi	r24, 0xFF	; 255
 28c:	89 83       	std	Y+1, r24	; 0x01
	}			
 28e:	fc cf       	rjmp	.-8      	; 0x288 <main+0x2c>

00000290 <__vector_7>:
}

SIGNAL(SIG_INTERRUPT6)  //Execute the following code if an INT6 interrupt has been generated. It is kept short.
{
 290:	1f 92       	push	r1
 292:	0f 92       	push	r0
 294:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 298:	0f 92       	push	r0
 29a:	11 24       	eor	r1, r1
 29c:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 2a0:	0f 92       	push	r0
 2a2:	8f 93       	push	r24
 2a4:	9f 93       	push	r25
 2a6:	ef 93       	push	r30
 2a8:	ff 93       	push	r31
 2aa:	cf 93       	push	r28
 2ac:	df 93       	push	r29
 2ae:	cd b7       	in	r28, 0x3d	; 61
 2b0:	de b7       	in	r29, 0x3e	; 62
	bToggle = 1;
 2b2:	81 e0       	ldi	r24, 0x01	; 1
 2b4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
	buttons = PINC;
 2b8:	86 e2       	ldi	r24, 0x26	; 38
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	fc 01       	movw	r30, r24
 2be:	80 81       	ld	r24, Z
 2c0:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <buttons>
}
 2c4:	df 91       	pop	r29
 2c6:	cf 91       	pop	r28
 2c8:	ff 91       	pop	r31
 2ca:	ef 91       	pop	r30
 2cc:	9f 91       	pop	r25
 2ce:	8f 91       	pop	r24
 2d0:	0f 90       	pop	r0
 2d2:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 2d6:	0f 90       	pop	r0
 2d8:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 2dc:	0f 90       	pop	r0
 2de:	1f 90       	pop	r1
 2e0:	18 95       	reti

000002e2 <__vector_9>:



SIGNAL(SIG_OUTPUT_COMPARE2) // This loop is executed every 5 ms (depending on the compare and match of timer 2)
{	
 2e2:	1f 92       	push	r1
 2e4:	0f 92       	push	r0
 2e6:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 2ea:	0f 92       	push	r0
 2ec:	11 24       	eor	r1, r1
 2ee:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 2f2:	0f 92       	push	r0
 2f4:	2f 93       	push	r18
 2f6:	3f 93       	push	r19
 2f8:	4f 93       	push	r20
 2fa:	5f 93       	push	r21
 2fc:	6f 93       	push	r22
 2fe:	7f 93       	push	r23
 300:	8f 93       	push	r24
 302:	9f 93       	push	r25
 304:	af 93       	push	r26
 306:	bf 93       	push	r27
 308:	ef 93       	push	r30
 30a:	ff 93       	push	r31
 30c:	cf 93       	push	r28
 30e:	df 93       	push	r29
 310:	cd b7       	in	r28, 0x3d	; 61
 312:	de b7       	in	r29, 0x3e	; 62
	if (bToggle)
 314:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 318:	88 23       	and	r24, r24
 31a:	09 f4       	brne	.+2      	; 0x31e <__vector_9+0x3c>
 31c:	46 c0       	rjmp	.+140    	; 0x3aa <__vector_9+0xc8>
	{
		switch(buttons & 0b11111000)
 31e:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <buttons>
 322:	88 2f       	mov	r24, r24
 324:	90 e0       	ldi	r25, 0x00	; 0
 326:	88 7f       	andi	r24, 0xF8	; 248
 328:	99 27       	eor	r25, r25
 32a:	80 32       	cpi	r24, 0x20	; 32
 32c:	91 05       	cpc	r25, r1
 32e:	09 f1       	breq	.+66     	; 0x372 <__vector_9+0x90>
 330:	81 32       	cpi	r24, 0x21	; 33
 332:	91 05       	cpc	r25, r1
 334:	34 f4       	brge	.+12     	; 0x342 <__vector_9+0x60>
 336:	88 30       	cpi	r24, 0x08	; 8
 338:	91 05       	cpc	r25, r1
 33a:	61 f1       	breq	.+88     	; 0x394 <__vector_9+0xb2>
 33c:	40 97       	sbiw	r24, 0x10	; 16
 33e:	11 f1       	breq	.+68     	; 0x384 <__vector_9+0xa2>
			LEDcountD = 0;				// Do it next time Flash is executed
			break;
			default:
			//PORTC &= 0b11111000;	//Turn off Port C LEDs
			//PORTG &= 0x11111100;	//Turn off Port G LEDs
			break;
 340:	32 c0       	rjmp	.+100    	; 0x3a6 <__vector_9+0xc4>

SIGNAL(SIG_OUTPUT_COMPARE2) // This loop is executed every 5 ms (depending on the compare and match of timer 2)
{	
	if (bToggle)
	{
		switch(buttons & 0b11111000)
 342:	80 34       	cpi	r24, 0x40	; 64
 344:	91 05       	cpc	r25, r1
 346:	69 f0       	breq	.+26     	; 0x362 <__vector_9+0x80>
 348:	80 38       	cpi	r24, 0x80	; 128
 34a:	91 05       	cpc	r25, r1
 34c:	09 f0       	breq	.+2      	; 0x350 <__vector_9+0x6e>
			LEDcountD = 0;				// Do it next time Flash is executed
			break;
			default:
			//PORTC &= 0b11111000;	//Turn off Port C LEDs
			//PORTG &= 0x11111100;	//Turn off Port G LEDs
			break;
 34e:	2b c0       	rjmp	.+86     	; 0x3a6 <__vector_9+0xc4>
	{
		switch(buttons & 0b11111000)
		{
			case 0b10000000:			//S5 center button
			//PORTC |= 0b00000100;	//Turn on Led5 if S5 is on
			LEDpattern = (LEDpattern & 0b00011111) | 0b01000000; // Swipe from Led1 to Led 5
 350:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <LEDpattern>
 354:	8f 71       	andi	r24, 0x1F	; 31
 356:	80 64       	ori	r24, 0x40	; 64
 358:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <LEDpattern>
			LEDcountD = 0;				// Do it next time Flash is executed
 35c:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <LEDcountD>
			break;
 360:	22 c0       	rjmp	.+68     	; 0x3a6 <__vector_9+0xc4>
			case 0b01000000:			//S4  upper button
			//PORTC |= 0b00000010;	 //Turn on Led4 if S4 is on
			LEDperiod++;				// Increase the number of loops to blink
 362:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <LEDperiod>
 366:	8f 5f       	subi	r24, 0xFF	; 255
 368:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <LEDperiod>
			LEDcountD = 0;				// Do it next time Flash is executed
 36c:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <LEDcountD>
			break;
 370:	1a c0       	rjmp	.+52     	; 0x3a6 <__vector_9+0xc4>
			case 0b00100000:			//S3 left button
			//PORTC |= 0b00000001;	//Turn on Led3 if S3 is on
			LEDpattern = (LEDpattern & 0b00011111) | 0b10000000; // Alternate the LEDS
 372:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <LEDpattern>
 376:	8f 71       	andi	r24, 0x1F	; 31
 378:	80 68       	ori	r24, 0x80	; 128
 37a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <LEDpattern>
			LEDcountD = 0;				// Do it next time Flash is executed
 37e:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <LEDcountD>
			break;
 382:	11 c0       	rjmp	.+34     	; 0x3a6 <__vector_9+0xc4>
			case 0b00010000:			//S2 lower button
			//PORTG |= 0b00000010;	//Turn on Led2 if S2 is on
			LEDperiod--;
 384:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <LEDperiod>
 388:	81 50       	subi	r24, 0x01	; 1
 38a:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <LEDperiod>
			LEDcountD = 0;				// Do it next time Flash is executed
 38e:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <LEDcountD>
			break;
 392:	09 c0       	rjmp	.+18     	; 0x3a6 <__vector_9+0xc4>
			case 0b00001000:			//S1 right button
			//PORTG |= 0b00000001;	//Turn on Led1 if S1 is on
			LEDpattern = (LEDpattern & 0b00011111) | 0b00100000; // Swipe from Led5 to Led1
 394:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <LEDpattern>
 398:	8f 71       	andi	r24, 0x1F	; 31
 39a:	80 62       	ori	r24, 0x20	; 32
 39c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <LEDpattern>
			LEDcountD = 0;				// Do it next time Flash is executed
 3a0:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <LEDcountD>
			break;
 3a4:	00 00       	nop
			default:
			//PORTC &= 0b11111000;	//Turn off Port C LEDs
			//PORTG &= 0x11111100;	//Turn off Port G LEDs
			break;
		}
		bToggle = 0;
 3a6:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
   }
   flashLEDs();
 3aa:	e5 de       	rcall	.-566    	; 0x176 <flashLEDs>
 3ac:	df 91       	pop	r29
 3ae:	cf 91       	pop	r28
 3b0:	ff 91       	pop	r31
 3b2:	ef 91       	pop	r30
 3b4:	bf 91       	pop	r27
 3b6:	af 91       	pop	r26
 3b8:	9f 91       	pop	r25
 3ba:	8f 91       	pop	r24
 3bc:	7f 91       	pop	r23
 3be:	6f 91       	pop	r22
 3c0:	5f 91       	pop	r21
 3c2:	4f 91       	pop	r20
 3c4:	3f 91       	pop	r19
 3c6:	2f 91       	pop	r18
 3c8:	0f 90       	pop	r0
 3ca:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 3ce:	0f 90       	pop	r0
 3d0:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 3d4:	0f 90       	pop	r0
 3d6:	1f 90       	pop	r1
 3d8:	18 95       	reti

000003da <_exit>:
 3da:	f8 94       	cli

000003dc <__stop_program>:
 3dc:	ff cf       	rjmp	.-2      	; 0x3dc <__stop_program>
