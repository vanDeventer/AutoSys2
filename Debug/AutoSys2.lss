
AutoSys2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000562  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004ee  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  00800100  00800100  00000562  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000562  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000594  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000060  00000000  00000000  000005d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000001eb  00000000  00000000  00000634  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000000f6  00000000  00000000  0000081f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000031a  00000000  00000000  00000915  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001bc  00000000  00000000  00000c30  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001cc  00000000  00000000  00000dec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000399  00000000  00000000  00000fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  00001351  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	57 c0       	rjmp	.+174    	; 0xb4 <__bad_interrupt>
   6:	00 00       	nop
   8:	55 c0       	rjmp	.+170    	; 0xb4 <__bad_interrupt>
   a:	00 00       	nop
   c:	53 c0       	rjmp	.+166    	; 0xb4 <__bad_interrupt>
   e:	00 00       	nop
  10:	51 c0       	rjmp	.+162    	; 0xb4 <__bad_interrupt>
  12:	00 00       	nop
  14:	4f c0       	rjmp	.+158    	; 0xb4 <__bad_interrupt>
  16:	00 00       	nop
  18:	4d c0       	rjmp	.+154    	; 0xb4 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	8d c1       	rjmp	.+794    	; 0x338 <__vector_7>
  1e:	00 00       	nop
  20:	49 c0       	rjmp	.+146    	; 0xb4 <__bad_interrupt>
  22:	00 00       	nop
  24:	b3 c1       	rjmp	.+870    	; 0x38c <__vector_9>
  26:	00 00       	nop
  28:	45 c0       	rjmp	.+138    	; 0xb4 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	43 c0       	rjmp	.+134    	; 0xb4 <__bad_interrupt>
  2e:	00 00       	nop
  30:	41 c0       	rjmp	.+130    	; 0xb4 <__bad_interrupt>
  32:	00 00       	nop
  34:	3f c0       	rjmp	.+126    	; 0xb4 <__bad_interrupt>
  36:	00 00       	nop
  38:	3d c0       	rjmp	.+122    	; 0xb4 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	3b c0       	rjmp	.+118    	; 0xb4 <__bad_interrupt>
  3e:	00 00       	nop
  40:	39 c0       	rjmp	.+114    	; 0xb4 <__bad_interrupt>
  42:	00 00       	nop
  44:	37 c0       	rjmp	.+110    	; 0xb4 <__bad_interrupt>
  46:	00 00       	nop
  48:	35 c0       	rjmp	.+106    	; 0xb4 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	33 c0       	rjmp	.+102    	; 0xb4 <__bad_interrupt>
  4e:	00 00       	nop
  50:	31 c0       	rjmp	.+98     	; 0xb4 <__bad_interrupt>
  52:	00 00       	nop
  54:	2f c0       	rjmp	.+94     	; 0xb4 <__bad_interrupt>
  56:	00 00       	nop
  58:	2d c0       	rjmp	.+90     	; 0xb4 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	2b c0       	rjmp	.+86     	; 0xb4 <__bad_interrupt>
  5e:	00 00       	nop
  60:	29 c0       	rjmp	.+82     	; 0xb4 <__bad_interrupt>
  62:	00 00       	nop
  64:	00 c2       	rjmp	.+1024   	; 0x466 <__vector_25>
  66:	00 00       	nop
  68:	25 c0       	rjmp	.+74     	; 0xb4 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	23 c0       	rjmp	.+70     	; 0xb4 <__bad_interrupt>
  6e:	00 00       	nop
  70:	21 c0       	rjmp	.+66     	; 0xb4 <__bad_interrupt>
  72:	00 00       	nop
  74:	1f c0       	rjmp	.+62     	; 0xb4 <__bad_interrupt>
  76:	00 00       	nop
  78:	1d c0       	rjmp	.+58     	; 0xb4 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	1b c0       	rjmp	.+54     	; 0xb4 <__bad_interrupt>
  7e:	00 00       	nop
  80:	19 c0       	rjmp	.+50     	; 0xb4 <__bad_interrupt>
  82:	00 00       	nop
  84:	17 c0       	rjmp	.+46     	; 0xb4 <__bad_interrupt>
  86:	00 00       	nop
  88:	15 c0       	rjmp	.+42     	; 0xb4 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	13 c0       	rjmp	.+38     	; 0xb4 <__bad_interrupt>
  8e:	00 00       	nop
  90:	11 c0       	rjmp	.+34     	; 0xb4 <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_clear_bss>:
  a0:	21 e0       	ldi	r18, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
  a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
  aa:	a7 30       	cpi	r26, 0x07	; 7
  ac:	b2 07       	cpc	r27, r18
  ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>
  b0:	1e d1       	rcall	.+572    	; 0x2ee <main>
  b2:	1b c2       	rjmp	.+1078   	; 0x4ea <_exit>

000000b4 <__bad_interrupt>:
  b4:	a5 cf       	rjmp	.-182    	; 0x0 <__vectors>

000000b6 <initGPIO>:

volatile uint16_t adc_value;  //Allocate the double byte memory space into which the result of the 10 bits Analog to Digital Converter (ADC) is stored.


int initGPIO(void)
{
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	cd b7       	in	r28, 0x3d	; 61
  bc:	de b7       	in	r29, 0x3e	; 62
	//Set up input output direction on Port C and G
	DDRB |= (1<<DB_LED);	// Set the display backlight's IO pin an an output. Leave other bits as they were.
  be:	84 e2       	ldi	r24, 0x24	; 36
  c0:	90 e0       	ldi	r25, 0x00	; 0
  c2:	24 e2       	ldi	r18, 0x24	; 36
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	f9 01       	movw	r30, r18
  c8:	20 81       	ld	r18, Z
  ca:	20 68       	ori	r18, 0x80	; 128
  cc:	fc 01       	movw	r30, r24
  ce:	20 83       	st	Z, r18
	DDRC = 0b00000111;		// Set the direction of the IO pins on Port C to output on the 3 least significant bits and input on the 5 higher ones. 5 buttons and 3 LEDs.
  d0:	87 e2       	ldi	r24, 0x27	; 39
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	27 e0       	ldi	r18, 0x07	; 7
  d6:	fc 01       	movw	r30, r24
  d8:	20 83       	st	Z, r18
	DDRG |= 0b00000011;		// set the direction of the IO pins on Port G's lower 2 bytes as output (LEDs 1 & 2). Leave the other bits as they were.
  da:	83 e3       	ldi	r24, 0x33	; 51
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	23 e3       	ldi	r18, 0x33	; 51
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	f9 01       	movw	r30, r18
  e4:	20 81       	ld	r18, Z
  e6:	23 60       	ori	r18, 0x03	; 3
  e8:	fc 01       	movw	r30, r24
  ea:	20 83       	st	Z, r18
	return(0);
  ec:	80 e0       	ldi	r24, 0x00	; 0
  ee:	90 e0       	ldi	r25, 0x00	; 0
}
  f0:	df 91       	pop	r29
  f2:	cf 91       	pop	r28
  f4:	08 95       	ret

000000f6 <initExtInt>:

int initExtInt(void)
{
  f6:	cf 93       	push	r28
  f8:	df 93       	push	r29
  fa:	cd b7       	in	r28, 0x3d	; 61
  fc:	de b7       	in	r29, 0x3e	; 62
	//Set up external Interrupts
	// The five Switches are ORed to Pin PE6 which is alternatively Int6
	EICRB |= (0<<ISC61) | (1<<ISC60);  //Any logical change to INT6 generates an interrupt
  fe:	8a e6       	ldi	r24, 0x6A	; 106
 100:	90 e0       	ldi	r25, 0x00	; 0
 102:	2a e6       	ldi	r18, 0x6A	; 106
 104:	30 e0       	ldi	r19, 0x00	; 0
 106:	f9 01       	movw	r30, r18
 108:	20 81       	ld	r18, Z
 10a:	20 61       	ori	r18, 0x10	; 16
 10c:	fc 01       	movw	r30, r24
 10e:	20 83       	st	Z, r18
	EIMSK |= (1<<INTF6);
 110:	8d e3       	ldi	r24, 0x3D	; 61
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	2d e3       	ldi	r18, 0x3D	; 61
 116:	30 e0       	ldi	r19, 0x00	; 0
 118:	f9 01       	movw	r30, r18
 11a:	20 81       	ld	r18, Z
 11c:	20 64       	ori	r18, 0x40	; 64
 11e:	fc 01       	movw	r30, r24
 120:	20 83       	st	Z, r18
	return(6);
 122:	86 e0       	ldi	r24, 0x06	; 6
 124:	90 e0       	ldi	r25, 0x00	; 0
}
 126:	df 91       	pop	r29
 128:	cf 91       	pop	r28
 12a:	08 95       	ret

0000012c <initTimer2>:


int initTimer2()
{
 12c:	cf 93       	push	r28
 12e:	df 93       	push	r29
 130:	cd b7       	in	r28, 0x3d	; 61
 132:	de b7       	in	r29, 0x3e	; 62
	/// Set up an internal Interrupt that will occur every 5 milliseconds.
	/// It uses the Timer Counter 2 in CTC mode with a pre-scaler of 256 and a value of 155 (it should be 155.25).
	// 
	TCCR2A = (1<<WGM21); // | (0<<WGM20);  //CTC mode
 134:	80 eb       	ldi	r24, 0xB0	; 176
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	28 e0       	ldi	r18, 0x08	; 8
 13a:	fc 01       	movw	r30, r24
 13c:	20 83       	st	Z, r18
	//TCCR2A |= (0<<COM2A1) | (0<<COM2A0); // Mormal port operation, OC2A is disconnected.
	TCCR2A |= (1<<CS22) | (1<<CS21); //| (0<<CS20); /// Divide source frequency source by 256.
 13e:	80 eb       	ldi	r24, 0xB0	; 176
 140:	90 e0       	ldi	r25, 0x00	; 0
 142:	20 eb       	ldi	r18, 0xB0	; 176
 144:	30 e0       	ldi	r19, 0x00	; 0
 146:	f9 01       	movw	r30, r18
 148:	20 81       	ld	r18, Z
 14a:	26 60       	ori	r18, 0x06	; 6
 14c:	fc 01       	movw	r30, r24
 14e:	20 83       	st	Z, r18
	TCNT2 = 0;	/// Make sure the timer counter is set to 0.
 150:	82 eb       	ldi	r24, 0xB2	; 178
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	fc 01       	movw	r30, r24
 156:	10 82       	st	Z, r1
	OCR2A = 155;
 158:	83 eb       	ldi	r24, 0xB3	; 179
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	2b e9       	ldi	r18, 0x9B	; 155
 15e:	fc 01       	movw	r30, r24
 160:	20 83       	st	Z, r18
	TIMSK2 = (1<<OCF2A); // Interrupt flag register to enable output compare.
 162:	80 e7       	ldi	r24, 0x70	; 112
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	22 e0       	ldi	r18, 0x02	; 2
 168:	fc 01       	movw	r30, r24
 16a:	20 83       	st	Z, r18
	return(2);
 16c:	82 e0       	ldi	r24, 0x02	; 2
 16e:	90 e0       	ldi	r25, 0x00	; 0
}
 170:	df 91       	pop	r29
 172:	cf 91       	pop	r28
 174:	08 95       	ret

00000176 <initADC>:

int initADC(){
 176:	cf 93       	push	r28
 178:	df 93       	push	r29
 17a:	cd b7       	in	r28, 0x3d	; 61
 17c:	de b7       	in	r29, 0x3e	; 62
	//Set up analog to digital conversion (ADC) 
	//ADMUX register
	//AVcc with external capacitor on AREF pin (the 2 following lines)
	ADMUX &= ~(1<<REFS1);  //Clear REFS1 (although it should be 0 at reset)
 17e:	8c e7       	ldi	r24, 0x7C	; 124
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	2c e7       	ldi	r18, 0x7C	; 124
 184:	30 e0       	ldi	r19, 0x00	; 0
 186:	f9 01       	movw	r30, r18
 188:	20 81       	ld	r18, Z
 18a:	2f 77       	andi	r18, 0x7F	; 127
 18c:	fc 01       	movw	r30, r24
 18e:	20 83       	st	Z, r18
	ADMUX |= (1<<REFS0);   //Set REFS0  
 190:	8c e7       	ldi	r24, 0x7C	; 124
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	2c e7       	ldi	r18, 0x7C	; 124
 196:	30 e0       	ldi	r19, 0x00	; 0
 198:	f9 01       	movw	r30, r18
 19a:	20 81       	ld	r18, Z
 19c:	20 64       	ori	r18, 0x40	; 64
 19e:	fc 01       	movw	r30, r24
 1a0:	20 83       	st	Z, r18
	ADMUX &= (0b11100000); //Single ended input on ADC0
 1a2:	8c e7       	ldi	r24, 0x7C	; 124
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	2c e7       	ldi	r18, 0x7C	; 124
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	f9 01       	movw	r30, r18
 1ac:	20 81       	ld	r18, Z
 1ae:	20 7e       	andi	r18, 0xE0	; 224
 1b0:	fc 01       	movw	r30, r24
 1b2:	20 83       	st	Z, r18
	ADMUX &= ~(1<<ADLAR);  //Making sure ADLAR is zero (somehow it was set to 1)
 1b4:	8c e7       	ldi	r24, 0x7C	; 124
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	2c e7       	ldi	r18, 0x7C	; 124
 1ba:	30 e0       	ldi	r19, 0x00	; 0
 1bc:	f9 01       	movw	r30, r18
 1be:	20 81       	ld	r18, Z
 1c0:	2f 7d       	andi	r18, 0xDF	; 223
 1c2:	fc 01       	movw	r30, r24
 1c4:	20 83       	st	Z, r18
	//The ACDC control and status register B ADCSRB
	ADCSRB &= ~(1<<ADTS2) & ~(1<<ADTS1) & ~(1<<ADTS0);  //Free running mode
 1c6:	8b e7       	ldi	r24, 0x7B	; 123
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	2b e7       	ldi	r18, 0x7B	; 123
 1cc:	30 e0       	ldi	r19, 0x00	; 0
 1ce:	f9 01       	movw	r30, r18
 1d0:	20 81       	ld	r18, Z
 1d2:	28 7f       	andi	r18, 0xF8	; 248
 1d4:	fc 01       	movw	r30, r24
 1d6:	20 83       	st	Z, r18
	//The ADC control and status register A ADCSRA
	ADCSRA |= (1<<ADPS2) | (1<<ADPS1) |(1<<ADPS0);//set sampling frequency pre-scaler to a division by 128
 1d8:	8a e7       	ldi	r24, 0x7A	; 122
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	2a e7       	ldi	r18, 0x7A	; 122
 1de:	30 e0       	ldi	r19, 0x00	; 0
 1e0:	f9 01       	movw	r30, r18
 1e2:	20 81       	ld	r18, Z
 1e4:	27 60       	ori	r18, 0x07	; 7
 1e6:	fc 01       	movw	r30, r24
 1e8:	20 83       	st	Z, r18
	ADCSRA |= (1<<ADEN)  | (1<<ADATE) | (1<<ADIE);//enable ADC, able ADC auto trigger, enable ADC interrupt
 1ea:	8a e7       	ldi	r24, 0x7A	; 122
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	2a e7       	ldi	r18, 0x7A	; 122
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	f9 01       	movw	r30, r18
 1f4:	20 81       	ld	r18, Z
 1f6:	28 6a       	ori	r18, 0xA8	; 168
 1f8:	fc 01       	movw	r30, r24
 1fa:	20 83       	st	Z, r18
	return(0);
 1fc:	80 e0       	ldi	r24, 0x00	; 0
 1fe:	90 e0       	ldi	r25, 0x00	; 0
}
 200:	df 91       	pop	r29
 202:	cf 91       	pop	r28
 204:	08 95       	ret

00000206 <flashLEDs>:

void  flashLEDs()		//This function will scroll or invert the 5 LEDs (5 LSB) based on the three MSB (scroll left, invert, scroll right).
{	
 206:	cf 93       	push	r28
 208:	df 93       	push	r29
 20a:	1f 92       	push	r1
 20c:	cd b7       	in	r28, 0x3d	; 61
 20e:	de b7       	in	r29, 0x3e	; 62
	unsigned char temp;			//Allocate a temporary byte. Note! it is not the same byte as the byte named temp in the main routine. Do not confuse them even if they have the same name.
	if (LEDcountD != 0)
 210:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <LEDcountD>
 214:	88 23       	and	r24, r24
 216:	31 f0       	breq	.+12     	; 0x224 <flashLEDs+0x1e>
	{
		LEDcountD--;			// Decrement the countdown timer for another 5ms until it reaches 0
 218:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <LEDcountD>
 21c:	81 50       	subi	r24, 0x01	; 1
 21e:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <LEDcountD>
		LEDpattern = (LEDpattern & 0b11100000)|temp;	// Update the LEDpattern with the current pattern while keeping flashing commands
		PORTG = (PORTG & 0x11111100) | (temp & 0b00000011);	//Update the 2 Port G LEDs
		temp = temp >>2;
		PORTC = (PORTC & 0b11111000) | temp;	//Update the 3 Port C LEDs
	}
}
 222:	60 c0       	rjmp	.+192    	; 0x2e4 <flashLEDs+0xde>
	{
		LEDcountD--;			// Decrement the countdown timer for another 5ms until it reaches 0
	} 
	else
	{
		LEDcountD = LEDperiod;	// Reset the countdown timer.
 224:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <LEDperiod>
 228:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <LEDcountD>
		temp = LEDpattern & 0b00011111; // Save the LED pattern.
 22c:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <LEDpattern>
 230:	8f 71       	andi	r24, 0x1F	; 31
 232:	89 83       	std	Y+1, r24	; 0x01
		switch (LEDpattern & 0b11100000)
 234:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <LEDpattern>
 238:	88 2f       	mov	r24, r24
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	80 7e       	andi	r24, 0xE0	; 224
 23e:	99 27       	eor	r25, r25
 240:	80 34       	cpi	r24, 0x40	; 64
 242:	91 05       	cpc	r25, r1
 244:	b9 f0       	breq	.+46     	; 0x274 <flashLEDs+0x6e>
 246:	80 38       	cpi	r24, 0x80	; 128
 248:	91 05       	cpc	r25, r1
 24a:	19 f0       	breq	.+6      	; 0x252 <flashLEDs+0x4c>
 24c:	80 97       	sbiw	r24, 0x20	; 32
 24e:	c9 f0       	breq	.+50     	; 0x282 <flashLEDs+0x7c>
				}
				temp = temp>>1;
				break;
			default:
				// Do nothing
				break;
 250:	27 c0       	rjmp	.+78     	; 0x2a0 <flashLEDs+0x9a>
		LEDcountD = LEDperiod;	// Reset the countdown timer.
		temp = LEDpattern & 0b00011111; // Save the LED pattern.
		switch (LEDpattern & 0b11100000)
		{
			case 0b10000000:
				temp = temp<<1;
 252:	89 81       	ldd	r24, Y+1	; 0x01
 254:	88 0f       	add	r24, r24
 256:	89 83       	std	Y+1, r24	; 0x01
				if (temp & 0b00100000)
 258:	89 81       	ldd	r24, Y+1	; 0x01
 25a:	88 2f       	mov	r24, r24
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	80 72       	andi	r24, 0x20	; 32
 260:	99 27       	eor	r25, r25
 262:	89 2b       	or	r24, r25
 264:	e1 f0       	breq	.+56     	; 0x29e <flashLEDs+0x98>
				{
					temp |= 0b00000001;
 266:	89 81       	ldd	r24, Y+1	; 0x01
 268:	81 60       	ori	r24, 0x01	; 1
 26a:	89 83       	std	Y+1, r24	; 0x01
					temp &= ~0b00100000;	// Do not keep a bit set where there is supposed to be a flashing command.
 26c:	89 81       	ldd	r24, Y+1	; 0x01
 26e:	8f 7d       	andi	r24, 0xDF	; 223
 270:	89 83       	std	Y+1, r24	; 0x01
				}
				break;
 272:	15 c0       	rjmp	.+42     	; 0x29e <flashLEDs+0x98>
			case 0b01000000:
				temp = ~temp;		// Invert the light pattern.
 274:	89 81       	ldd	r24, Y+1	; 0x01
 276:	80 95       	com	r24
 278:	89 83       	std	Y+1, r24	; 0x01
				temp &= 0b00011111;	// Clear the flashing command.
 27a:	89 81       	ldd	r24, Y+1	; 0x01
 27c:	8f 71       	andi	r24, 0x1F	; 31
 27e:	89 83       	std	Y+1, r24	; 0x01
				break;
 280:	0f c0       	rjmp	.+30     	; 0x2a0 <flashLEDs+0x9a>
			case 0b00100000:
				if (temp & 0b00000001)
 282:	89 81       	ldd	r24, Y+1	; 0x01
 284:	88 2f       	mov	r24, r24
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	81 70       	andi	r24, 0x01	; 1
 28a:	99 27       	eor	r25, r25
 28c:	89 2b       	or	r24, r25
 28e:	19 f0       	breq	.+6      	; 0x296 <flashLEDs+0x90>
				{
						temp |= 0b00100000;
 290:	89 81       	ldd	r24, Y+1	; 0x01
 292:	80 62       	ori	r24, 0x20	; 32
 294:	89 83       	std	Y+1, r24	; 0x01
				}
				temp = temp>>1;
 296:	89 81       	ldd	r24, Y+1	; 0x01
 298:	86 95       	lsr	r24
 29a:	89 83       	std	Y+1, r24	; 0x01
				break;
 29c:	01 c0       	rjmp	.+2      	; 0x2a0 <flashLEDs+0x9a>
				if (temp & 0b00100000)
				{
					temp |= 0b00000001;
					temp &= ~0b00100000;	// Do not keep a bit set where there is supposed to be a flashing command.
				}
				break;
 29e:	00 00       	nop
				break;
			default:
				// Do nothing
				break;
	}
		LEDpattern = (LEDpattern & 0b11100000)|temp;	// Update the LEDpattern with the current pattern while keeping flashing commands
 2a0:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <LEDpattern>
 2a4:	98 2f       	mov	r25, r24
 2a6:	90 7e       	andi	r25, 0xE0	; 224
 2a8:	89 81       	ldd	r24, Y+1	; 0x01
 2aa:	89 2b       	or	r24, r25
 2ac:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDpattern>
		PORTG = (PORTG & 0x11111100) | (temp & 0b00000011);	//Update the 2 Port G LEDs
 2b0:	84 e3       	ldi	r24, 0x34	; 52
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	fc 01       	movw	r30, r24
 2b6:	80 81       	ld	r24, Z
 2b8:	84 e3       	ldi	r24, 0x34	; 52
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	29 81       	ldd	r18, Y+1	; 0x01
 2be:	23 70       	andi	r18, 0x03	; 3
 2c0:	fc 01       	movw	r30, r24
 2c2:	20 83       	st	Z, r18
		temp = temp >>2;
 2c4:	89 81       	ldd	r24, Y+1	; 0x01
 2c6:	86 95       	lsr	r24
 2c8:	86 95       	lsr	r24
 2ca:	89 83       	std	Y+1, r24	; 0x01
		PORTC = (PORTC & 0b11111000) | temp;	//Update the 3 Port C LEDs
 2cc:	88 e2       	ldi	r24, 0x28	; 40
 2ce:	90 e0       	ldi	r25, 0x00	; 0
 2d0:	28 e2       	ldi	r18, 0x28	; 40
 2d2:	30 e0       	ldi	r19, 0x00	; 0
 2d4:	f9 01       	movw	r30, r18
 2d6:	20 81       	ld	r18, Z
 2d8:	32 2f       	mov	r19, r18
 2da:	38 7f       	andi	r19, 0xF8	; 248
 2dc:	29 81       	ldd	r18, Y+1	; 0x01
 2de:	23 2b       	or	r18, r19
 2e0:	fc 01       	movw	r30, r24
 2e2:	20 83       	st	Z, r18
	}
}
 2e4:	00 00       	nop
 2e6:	0f 90       	pop	r0
 2e8:	df 91       	pop	r29
 2ea:	cf 91       	pop	r28
 2ec:	08 95       	ret

000002ee <main>:

int main(void){
 2ee:	cf 93       	push	r28
 2f0:	df 93       	push	r29
 2f2:	1f 92       	push	r1
 2f4:	cd b7       	in	r28, 0x3d	; 61
 2f6:	de b7       	in	r29, 0x3e	; 62
	unsigned char temp = 0x0F;		// Allocate memory for temp. It is initialized to 15 for demonstration purposes only.
 2f8:	8f e0       	ldi	r24, 0x0F	; 15
 2fa:	89 83       	std	Y+1, r24	; 0x01
	
	LEDpattern = 0b01000100;		// Flash the pattern the LED pattern 00100
 2fc:	84 e4       	ldi	r24, 0x44	; 68
 2fe:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDpattern>
	LEDperiod = 100;				// LEDperiod x initTimer2 period.
 302:	84 e6       	ldi	r24, 0x64	; 100
 304:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <LEDperiod>
	LEDcountD = 0;
 308:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <LEDcountD>
	
	temp = initGPIO();				// Set up the data direction register for both ports C and G
	temp = initExtInt();			// Setup external interrupts
 30c:	d4 de       	rcall	.-600    	; 0xb6 <initGPIO>
	temp = initTimer2();			// Setup 5ms internal interrupt
 30e:	89 83       	std	Y+1, r24	; 0x01
 310:	f2 de       	rcall	.-540    	; 0xf6 <initExtInt>
	temp = initADC();				// Setup the Analog to Digital Converter
 312:	89 83       	std	Y+1, r24	; 0x01
 314:	0b df       	rcall	.-490    	; 0x12c <initTimer2>
 316:	89 83       	std	Y+1, r24	; 0x01
	ADCSRA |= (1<<ADSC);			//Start ADC
 318:	2e df       	rcall	.-420    	; 0x176 <initADC>
 31a:	89 83       	std	Y+1, r24	; 0x01
 31c:	8a e7       	ldi	r24, 0x7A	; 122
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	2a e7       	ldi	r18, 0x7A	; 122
 322:	30 e0       	ldi	r19, 0x00	; 0
 324:	f9 01       	movw	r30, r18
 326:	20 81       	ld	r18, Z
 328:	20 64       	ori	r18, 0x40	; 64

	sei();							// Set Global Interrupts
 32a:	fc 01       	movw	r30, r24
	
	while(1){						// LOOP: does not do much more than increase temp.
		temp++;
 32c:	20 83       	st	Z, r18
 32e:	78 94       	sei
 330:	89 81       	ldd	r24, Y+1	; 0x01
	}			
 332:	8f 5f       	subi	r24, 0xFF	; 255
 334:	89 83       	std	Y+1, r24	; 0x01
 336:	fc cf       	rjmp	.-8      	; 0x330 <main+0x42>

00000338 <__vector_7>:
}

SIGNAL(SIG_INTERRUPT6)  //Execute the following code if an INT6 interrupt has been generated. It is kept short.
{
 338:	1f 92       	push	r1
 33a:	0f 92       	push	r0
 33c:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 340:	0f 92       	push	r0
 342:	11 24       	eor	r1, r1
 344:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 348:	0f 92       	push	r0
 34a:	8f 93       	push	r24
 34c:	9f 93       	push	r25
 34e:	ef 93       	push	r30
 350:	ff 93       	push	r31
 352:	cf 93       	push	r28
 354:	df 93       	push	r29
 356:	cd b7       	in	r28, 0x3d	; 61
 358:	de b7       	in	r29, 0x3e	; 62
	bToggle = 1;
 35a:	81 e0       	ldi	r24, 0x01	; 1
 35c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
	buttons = PINC;
 360:	86 e2       	ldi	r24, 0x26	; 38
 362:	90 e0       	ldi	r25, 0x00	; 0
 364:	fc 01       	movw	r30, r24
 366:	80 81       	ld	r24, Z
 368:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <buttons>
}
 36c:	00 00       	nop
 36e:	df 91       	pop	r29
 370:	cf 91       	pop	r28
 372:	ff 91       	pop	r31
 374:	ef 91       	pop	r30
 376:	9f 91       	pop	r25
 378:	8f 91       	pop	r24
 37a:	0f 90       	pop	r0
 37c:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 380:	0f 90       	pop	r0
 382:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 386:	0f 90       	pop	r0
 388:	1f 90       	pop	r1
 38a:	18 95       	reti

0000038c <__vector_9>:



SIGNAL(SIG_OUTPUT_COMPARE2){ // This loop is executed every 5 ms (depending on the compare and match of timer 2)	
 38c:	1f 92       	push	r1
 38e:	0f 92       	push	r0
 390:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 394:	0f 92       	push	r0
 396:	11 24       	eor	r1, r1
 398:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 39c:	0f 92       	push	r0
 39e:	2f 93       	push	r18
 3a0:	3f 93       	push	r19
 3a2:	4f 93       	push	r20
 3a4:	5f 93       	push	r21
 3a6:	6f 93       	push	r22
 3a8:	7f 93       	push	r23
 3aa:	8f 93       	push	r24
 3ac:	9f 93       	push	r25
 3ae:	af 93       	push	r26
 3b0:	bf 93       	push	r27
 3b2:	ef 93       	push	r30
 3b4:	ff 93       	push	r31
 3b6:	cf 93       	push	r28
 3b8:	df 93       	push	r29
 3ba:	cd b7       	in	r28, 0x3d	; 61
 3bc:	de b7       	in	r29, 0x3e	; 62
	// Update the LED sequence
	cli();					// Disable the global interrupts to prevent accidental corruption of the results while the two bytes.
 3be:	f8 94       	cli
		if (adc_value>852){		
 3c0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <adc_value>
 3c4:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <adc_value+0x1>
 3c8:	85 35       	cpi	r24, 0x55	; 85
 3ca:	93 40       	sbci	r25, 0x03	; 3
 3cc:	20 f0       	brcs	.+8      	; 0x3d6 <__vector_9+0x4a>
			LEDpattern = 0b00011111;
 3ce:	8f e1       	ldi	r24, 0x1F	; 31
 3d0:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDpattern>
 3d4:	2e c0       	rjmp	.+92     	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
		} 
		else if(adc_value>682){
 3d6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <adc_value>
 3da:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <adc_value+0x1>
 3de:	8b 3a       	cpi	r24, 0xAB	; 171
 3e0:	92 40       	sbci	r25, 0x02	; 2
 3e2:	20 f0       	brcs	.+8      	; 0x3ec <__vector_9+0x60>
			LEDpattern = 0b00001111;
 3e4:	8f e0       	ldi	r24, 0x0F	; 15
 3e6:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDpattern>
 3ea:	23 c0       	rjmp	.+70     	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
		}
		else if(adc_value>511){
 3ec:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <adc_value>
 3f0:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <adc_value+0x1>
 3f4:	81 15       	cp	r24, r1
 3f6:	92 40       	sbci	r25, 0x02	; 2
 3f8:	20 f0       	brcs	.+8      	; 0x402 <__FUSE_REGION_LENGTH__+0x2>
			LEDpattern = 0b00000111;
 3fa:	87 e0       	ldi	r24, 0x07	; 7
 3fc:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDpattern>
 400:	18 c0       	rjmp	.+48     	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
		}
		else if(adc_value>341){
 402:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <adc_value>
 406:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <adc_value+0x1>
 40a:	86 35       	cpi	r24, 0x56	; 86
 40c:	91 40       	sbci	r25, 0x01	; 1
 40e:	20 f0       	brcs	.+8      	; 0x418 <__FUSE_REGION_LENGTH__+0x18>
			LEDpattern = 0b00000011;
 410:	83 e0       	ldi	r24, 0x03	; 3
 412:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDpattern>
 416:	0d c0       	rjmp	.+26     	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
		}
		else if(adc_value>170){
 418:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <adc_value>
 41c:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <adc_value+0x1>
 420:	8b 3a       	cpi	r24, 0xAB	; 171
 422:	91 05       	cpc	r25, r1
 424:	20 f0       	brcs	.+8      	; 0x42e <__FUSE_REGION_LENGTH__+0x2e>
			LEDpattern = 0b00000001;
 426:	81 e0       	ldi	r24, 0x01	; 1
 428:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <LEDpattern>
 42c:	02 c0       	rjmp	.+4      	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
		}
		else{
			LEDpattern = 0b00000000;
 42e:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <LEDpattern>
		};
			 
	sei();					// re-enable the global interrupts

   flashLEDs();
 432:	78 94       	sei
}
 434:	e8 de       	rcall	.-560    	; 0x206 <flashLEDs>
 436:	00 00       	nop
 438:	df 91       	pop	r29
 43a:	cf 91       	pop	r28
 43c:	ff 91       	pop	r31
 43e:	ef 91       	pop	r30
 440:	bf 91       	pop	r27
 442:	af 91       	pop	r26
 444:	9f 91       	pop	r25
 446:	8f 91       	pop	r24
 448:	7f 91       	pop	r23
 44a:	6f 91       	pop	r22
 44c:	5f 91       	pop	r21
 44e:	4f 91       	pop	r20
 450:	3f 91       	pop	r19
 452:	2f 91       	pop	r18
 454:	0f 90       	pop	r0
 456:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 45a:	0f 90       	pop	r0
 45c:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 460:	0f 90       	pop	r0
 462:	1f 90       	pop	r1
 464:	18 95       	reti

00000466 <__vector_25>:

ISR(ADC_vect){
 466:	1f 92       	push	r1
 468:	0f 92       	push	r0
 46a:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 46e:	0f 92       	push	r0
 470:	11 24       	eor	r1, r1
 472:	00 90 5b 00 	lds	r0, 0x005B	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 476:	0f 92       	push	r0
 478:	2f 93       	push	r18
 47a:	3f 93       	push	r19
 47c:	8f 93       	push	r24
 47e:	9f 93       	push	r25
 480:	ef 93       	push	r30
 482:	ff 93       	push	r31
 484:	cf 93       	push	r28
 486:	df 93       	push	r29
 488:	cd b7       	in	r28, 0x3d	; 61
 48a:	de b7       	in	r29, 0x3e	; 62
	adc_value = ADCL;		//Load the low byte of the ADC result
 48c:	88 e7       	ldi	r24, 0x78	; 120
 48e:	90 e0       	ldi	r25, 0x00	; 0
 490:	fc 01       	movw	r30, r24
 492:	80 81       	ld	r24, Z
 494:	88 2f       	mov	r24, r24
 496:	90 e0       	ldi	r25, 0x00	; 0
 498:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <adc_value+0x1>
 49c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <adc_value>
	adc_value += (ADCH<<8); //shift the high byte by 8bits to put the high byte in the variable
 4a0:	89 e7       	ldi	r24, 0x79	; 121
 4a2:	90 e0       	ldi	r25, 0x00	; 0
 4a4:	fc 01       	movw	r30, r24
 4a6:	80 81       	ld	r24, Z
 4a8:	88 2f       	mov	r24, r24
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	98 2f       	mov	r25, r24
 4ae:	88 27       	eor	r24, r24
 4b0:	9c 01       	movw	r18, r24
 4b2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <adc_value>
 4b6:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <adc_value+0x1>
 4ba:	82 0f       	add	r24, r18
 4bc:	93 1f       	adc	r25, r19
 4be:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <adc_value+0x1>
 4c2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <adc_value>
 4c6:	00 00       	nop
 4c8:	df 91       	pop	r29
 4ca:	cf 91       	pop	r28
 4cc:	ff 91       	pop	r31
 4ce:	ef 91       	pop	r30
 4d0:	9f 91       	pop	r25
 4d2:	8f 91       	pop	r24
 4d4:	3f 91       	pop	r19
 4d6:	2f 91       	pop	r18
 4d8:	0f 90       	pop	r0
 4da:	00 92 5b 00 	sts	0x005B, r0	; 0x80005b <__TEXT_REGION_LENGTH__+0x7e005b>
 4de:	0f 90       	pop	r0
 4e0:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 4e4:	0f 90       	pop	r0
 4e6:	1f 90       	pop	r1
 4e8:	18 95       	reti

000004ea <_exit>:
 4ea:	f8 94       	cli

000004ec <__stop_program>:
 4ec:	ff cf       	rjmp	.-2      	; 0x4ec <__stop_program>
